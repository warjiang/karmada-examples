<!DOCTYPE html>
<html>
<head>
    <title>Prometheus Metrics</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.3.2/dist/echarts.min.js"></script>
</head>
<body>
    <form id="scrape-form">
        <label for="namespace">Namespace:</label>
        <input type="text" id="namespace" name="namespace" value="karmada-system">
        <label for="pod">Pod:</label>
        <input type="text" id="pod" name="pod" value="karmada-scheduler-7bd4659f9f-8lfb5">
        <label for="port">Port:</label>
        <input type="text" id="port" name="port" value="10351">
        <button type="submit">Scrape Pod</button>
    </form>
    <br>

    <form id="query-form">
        <label for="metric-name">Metric Name:</label>
        <select id="metric-name"></select>
        <label for="labels">Labels (key=value,key2=value2):</label>
        <input type="text" id="labels" name="labels" placeholder="e.g., verb=GET,code=200">
        <button type="submit">Query Metrics</button>
    </form>
    <br>

    <div id="main" style="width: 100%;height:600px;"></div>
    <script type="text/javascript">
        var myChart = echarts.init(document.getElementById('main'));

        // Specify the configuration items and data for the chart
        var option = {
            title: {
                text: 'Metrics'
            },
            tooltip: {},
            legend: {
                data:[]
            },
            xAxis: {
                type: 'time'
            },
            yAxis: {},
            series: []
        };

        // Display the chart
        myChart.setOption(option);

        document.getElementById('scrape-form').addEventListener('submit', function(event) {
            event.preventDefault();
            const namespace = document.getElementById('namespace').value;
            const pod = document.getElementById('pod').value;
            const port = document.getElementById('port').value;
            fetch('/scrape/pod', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    namespace: namespace,
                    name: pod,
                    port: port
                })
            }).then(() => {
                // After scraping, refresh metric names and fetch a default metric
                fetchMetricNames();
                fetchMetrics('apiserver_request_total');
            });
        });

        document.getElementById('query-form').addEventListener('submit', function(event) {
            event.preventDefault();
            const metricName = document.getElementById('metric-name').value;
            const labelsInput = document.getElementById('labels').value;
            const labels = {};
            labelsInput.split(',').forEach(pair => {
                const [key, value] = pair.split('=');
                if (key && value) {
                    labels[key.trim()] = value.trim();
                }
            });
            fetchMetrics(metricName, labels);
        });

        function fetchMetricNames() {
            fetch('/metrics/names')
                .then(response => response.json())
                .then(data => {
                    const select = document.getElementById('metric-name');
                    select.innerHTML = ''; // Clear existing options
                    data.forEach(name => {
                        const option = document.createElement('option');
                        option.value = name;
                        option.textContent = name;
                        select.appendChild(option);
                    });
                });
        }

        function fetchMetrics(name, labels = {}) {
            let url = '/metrics/' + name;
            const params = new URLSearchParams();
            for (const key in labels) {
                params.append(key, labels[key]);
            }
            if (params.toString()) {
                url += '?' + params.toString();
            }

            fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (!Array.isArray(data)) {
                        // Clear the chart and return if data is not valid
                        myChart.setOption({
                            legend: { data: [] },
                            series: []
                        });
                        return;
                    }
                    // group metrics by labels
                    const groupedMetrics = data.reduce((acc, metric) => {
                        const key = JSON.stringify(metric.Labels);
                        if (!acc[key]) {
                            acc[key] = [];
                        }
                        acc[key].push(metric);
                        return acc;
                    }, {});

                    const series = [];
                    const legendData = [];
                    for (const key in groupedMetrics) {
                        let metrics = groupedMetrics[key];

                        // Sort by timestamp and take the last 100 points
                        metrics.sort((a, b) => a.Timestamp - b.Timestamp);
                        if (metrics.length > 100) {
                            metrics = metrics.slice(metrics.length - 100);
                        }

                        const legend = (metrics[0].Labels || []).map(l => `${l.Name}=${l.Value}`).join(',');
                        legendData.push(legend);

                        let processedData = [];
                        const metricType = metrics[0].Type; // Get the metric type

                        if (metricType === 'COUNTER') {
                            // Calculate rate for COUNTER
                            for (let i = 1; i < metrics.length; i++) {
                                const prev = metrics[i - 1];
                                const curr = metrics[i];
                                const timeDiff = (curr.Timestamp - prev.Timestamp) / 1000; // in seconds
                                if (timeDiff > 0) {
                                    const rate = (curr.Value - prev.Value) / timeDiff;
                                    processedData.push([curr.Timestamp, rate]);
                                }
                            }
                        } else {
                            // For GAUGE, HISTOGRAM, SUMMARY, just use raw values
                            // Note: More advanced visualization for HISTOGRAM/SUMMARY (e.g., quantiles) would require more complex logic.
                            processedData = metrics.map(m => [m.Timestamp, m.Value]);
                        }

                        series.push({
                            name: legend,
                            type: 'line',
                            data: processedData
                        });
                    }

                    myChart.setOption({
                        legend: {
                            data: legendData
                        },
                        xAxis: {
                            type: 'time',
                            axisLabel: {
                                formatter: function (value) {
                                    console.log('value', value)
                                    var date = new Date(value);
                                    var hours = date.getHours().toString().padStart(2, '0');
                                    var minutes = date.getMinutes().toString().padStart(2, '0');
                                    var seconds = date.getSeconds().toString().padStart(2, '0');
                                    return hours + ':' + minutes + ':' + seconds;
                                }
                            }
                        },
                        yAxis: {
                            type: 'value'
                        },
                        series: series
                    });
                });
        }

        // Initial fetch of metric names when the page loads
        fetchMetricNames();
    </script>
</body>
</html>
